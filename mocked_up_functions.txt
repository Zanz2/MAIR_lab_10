#These functions might help implementing 1b, i added small comments on what they do,
#hopefully it makes sense


# reads the restaurants database, finds mathces based on the fpl array (contained in dialogue state)
# example fpl: [False, "cheap", False]
# returns = array of arrays that contain restaurant info for restaurants that are cheap
# example fpl: ["persian", "cheap", "south"]
# returns an array of arrarys that contain restaurant info again, for restaurants
# that serve persian cuisine, are cheap and are located south

# one thing to note: when we're looking for a restaurant we say moderately priced
# however in the csv it is stated as "moderate" price range, so i map it to that here
def lookup_restaurant(dialogue_state):
	restaurant_data = pd.read_csv('restaurant_info.csv', dtype="str")
	eligible_choices = []
	pref_array = dialogue_state.user_preference_array_fpl
	if pref_array[2] == "moderately":
		pref_array[2] = "moderate"

	for index, row in restaurant_data.iterrows():
		valid_array = [False, False, False]

		restaurant_info_array = row.tolist()
		if pref_array[0] is False or pref_array[0] == restaurant_info_array[3]:
			valid_array[0] = True
		if pref_array[1] is False or pref_array[1] == restaurant_info_array[1]:
			valid_array[1] = True
		if pref_array[2] is False or pref_array[2] == restaurant_info_array[2]:
			valid_array[2] = True
		if all(valid_array):
			eligible_choices.append(restaurant_info_array)
	return eligible_choices

#Checks words for misspellings, the word with the smallest levenshtein distance
# is used as a substitute
# INPUT: word to be checked, for example chinse (chinese misspelling)
# OUTPUT:
#match_dict = {
#        "correct_word": "chinese",
#        "type": "food_type",
#        "index": 0,
#        "lv_distance": 1  # 1 edit necessary
#}
#OR outputs False if a match is not found
# the blacklist array contains words that get corrected by error

def check_levenshtein(self, word): # similar to the above function, but we run this after
    blacklist = ["west", "would", "want", "world", "a", "part", "can", "what"]
    # words that get confused and changed easily frequently belong in the blacklist
    if word in blacklist:
        return False
    match_dict = {
        "correct_word": False,
        "type": False,
        "index": -1,
        "lv_distance": 4  # max allowed distance, if its 4 at the end we return false
    }
    loop_array = ["food_type", "price_range", "location"]
    for type_index, value_type in enumerate(loop_array):
        for element in self.preference_dict[value_type]:
            lv_distance = Levenshtein.distance(element, word)
            if lv_distance < match_dict["lv_distance"] :
                match_dict["lv_distance"] = lv_distance
                match_dict["type"] = value_type
                match_dict["index"] = type_index
                match_dict["correct_word"] = element
                # if lv_distance < 3: print(word+" changed into "+element) # debug that prints the word changes
    if match_dict["lv_distance"] < 3:
        # i set this to less than 3, because more was giving me problems, with 3 this is what happened:
        '''
        for changed into world
        food changed into world
        for changed into world
        food changed into world
        '''
        return match_dict
    return False

#EXAMPLES
self.user_preference_array_fpl = ["chinese","cheap","south"]
self.user_preference_array_fpl = ["chinese",False,"south"] (in this case False is like wildcard match, any)
self.user_preference_array_fpl = [False, False, False]  # keyword array, first index is for food
# second index is for price range, third index is for location


# this is a keyword matching list that completes the required part of this assignement
# if sentance contains chinese, we know we have a food type then, etc for the others
self.preference_dict = {
    "food_type" : [
        "chinese",
        "swedish",
        "tuscan",
        "international",
        "catalan",
        "cuban",
        "persian",
        "bistro",
        "world"
    ],
    "price_range" : [
        "expensive",
        "moderately",
        "cheap"
    ],
    "location" : [
        "center",
        "south",
        "west",
        "east",
        "north"
    ]
}

# This is a dict of system messages all in one place, so usage could look like this
print(dialogue_state.messages["hello"])
self.messages = {
    "hello1": "Hi, welcome to the group 10 dialogue system.",
    "hello2": "You can ask for restaurants by area , price range or food type . How may I help you?",
    "error": "I did not understand what you said, can you rephrase that?",
    "askmore": "Would you like to specify any other preferences?",
    "askfoodtype": "What kind of cuisine would you like to eat?",
    "askpricerange": "Which price range do you prefer?",
    "asklocation": "What location would you like to eat at?",
    "valid": "Thanks for the info, press ENTER the restaurant(s) we found",
    "notfound": "Sorry, we couldnt find any restaurants matching your preferences.",
}